```
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```

```
(print (A 1 10)) ; 1024
(print (A 2 4))  ; 65536
(print (A 3 3))  ; 65536
```

`(define (f n) (A 0 n))`
置き換えモデルでプロセスを示すと,

```
(f n)
(A 0 n)
(* 2 n)
```

となる. よって,

* f(n) = 2 * n

`(define (g n) (A 1 n))`
置き換えモデルでプロセスを示すと,
n=0の時,

```
(g 0)
(A 1 0)
0
```

またn=1の時,

```
(g 1)
(A 1 1)
2
```

そして, n(n>=2)の時,

```
(g n)
(A 1 n)
(A (- 1 1) (A 1 (- n 1)))
(A 0 (A 1 n-1))
(A 0 (A 0 (A 1 (- n-1 1))))
(A 0 (A 0 (A 1 n-2)))
...
(A 0 (A 0 (... (A 1 (- n-(n-2) 1)))))
(A 0 (A 0 (... (A 1 1))))
(A 0 (A 0 (... 2)))
```

となる. ここで... と省略したものを含め, 第2オペランドが2のものが出現するまでにn-1回(A 0 x)を適用するため,
(= x 0)は真であり(* 2 y)が適用される.
よって, g(n) = 2 ^ nとなる.

まとめると,

* n =  0のとき, g(n) = 0
* n >= 1のとき, g(n) = 2 ^ n

`(define (h n) (A 2 n))`
置き換えモデルでプロセスを示すと,
n=0の時,

```
(h 0)
(A 2 0)
0
```

n=1の時,

```
(h 1)
(A 2 1)
2
```

n(n>=2)の時,

```
(h n)
(A 2 n)
(A (- 2 1) (A 2 (- n 1)))
(A 1 (A 2 n-1))
; ここで, (define (g n) (A 1 n)) より
(g (A 2 n-1)))
(g (A (- 2 1) (A 2 (- n-1 1))))
(g (A 1 (A 2 n-2)))
(g (g (A 2 n-2)))
...
(g (g (... (A 2 1))))
(g (g (... 2)))
```
となる. ここで... と省略したものを含め, 第2オペランドが2のものが出現するまでにn-1回(g x)を適用するため,
は2に(g n) をn-1回適用したものとなる.
すなわち, h(n) = 2 ^ (2 ^ n)となる.

まとめると,

* n =  0のとき, h(n) = 0
* n =  1のとき, h(n) = 2
* n >= 2のとき, h(n) = 2 ^ (2 ^ n)
