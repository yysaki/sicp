(lambda ⟨vars⟩
  (define u ⟨e1⟩)
  (define v ⟨e2⟩)
  ⟨e3⟩)

; 本文中の手続きの式⟨e3⟩を評価する時, 定義を逐次的に解釈する時に環境がどう構造化されるかと,

; +--------------------+
; | <vars>             |
; |                    |
; | (define u <e1>)    |
; | (define v <e2>)    |
; + e3                 |
; +--------------------+

; 上に記述したように定義を掃き出した場合にどう構造化されるかを比べ, 実際の環境の図を描け.

(lambda ⟨vars⟩
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u ⟨e1⟩)
    (set! v ⟨e2⟩)
    ⟨e3⟩))


; +--------------------+
; | <vars>             |
; |                    |
; +--------------------+
;        ^
;        |
; +--------------------+
; | u: -------------------> '*unassigned
; | v: -------------------> '*unassigned
; |                    |
; | (set! u <e1>)      |
; | (set! v <e2>)      |
; + e3                 |
; +--------------------+

; 余計なフレームを構成せずに解釈系が内部定義の「同時」有効範囲規則を実装する方法を設計せよ.

; A. 余計なlet(lambda)を使わないように変換する.

(lambda ⟨vars⟩
  (define u '*unassigned*)
  (define v '*unassigned*)
  (set! u ⟨e1⟩)
  (set! v ⟨e2⟩)
  ⟨e3⟩))
